{"version":3,"sources":["../../../src/adapters/eurostat/JsonStatFn.js"],"names":["URL_ID_COUNTRY","hmIdCountry","isHmFetched","_fnFetchHmIdCountry","fetch","then","response","json","hm","catch","err","Promise","resolve","_fnIdToCountry","id","name","_combineToArr","dGeo","sGeo","arr","forEach","index","value","push","_splitForConfig","categories","data","max","Number","NEGATIVE_INFINITY","min","POSITIVE_INFINITY","item","country","y","c","_combineToHm","ids","_trHmToData","JsonStatFn","createGeoSlice","configSlice","ds","Dataset","_sGeo","Data","time","length","maxIndex","Dimension","crGeoSeria","map","obj","filter","date","trJsonToCategory","sort","compareByValueId","fold","trJsonToSeria"],"mappings":"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","file":"JsonStatFn.js","sourcesContent":["import JSONstat from 'jsonstat';\r\n\r\nimport AdapterFn from '../AdapterFn'\r\nimport { Box, getFromNullable } from '../../utils/fnStyle'\r\n\r\nconst URL_ID_COUNTRY = './data/eurostat/id-country.json';\r\n\r\nlet hmIdCountry = {};\r\nlet isHmFetched = false;\r\nconst _fnFetchHmIdCountry = () => {\r\n   return (!isHmFetched)\r\n      ? fetch(URL_ID_COUNTRY)\r\n          .then((response) => {\r\n            return response.json();\r\n          })\r\n          .then((json) => {\r\n             hmIdCountry = json.hm;\r\n             isHmFetched = true;\r\n             return hmIdCountry;\r\n          })\r\n          .catch((err) => { return hmIdCountry; })\r\n     : Promise.resolve(hmIdCountry);\r\n}\r\n\r\nconst _fnIdToCountry = (id) => {\r\n   const name = hmIdCountry[id];\r\n   return (name) ? name : id;\r\n}\r\n\r\nconst _combineToArr = (dGeo, sGeo) => {\r\n  const arr = [];\r\n  dGeo.forEach((id, index) => {\r\n    if (sGeo[index] != null && sGeo[index].value != null){\r\n      arr.push({ id, value : sGeo[index].value });\r\n    }\r\n  })\r\n  return arr;\r\n}\r\nconst _splitForConfig = (arr) => {\r\n   const categories = []\r\n       , data = [];\r\n   let max = Number.NEGATIVE_INFINITY\r\n     , min = Number.POSITIVE_INFINITY;\r\n   arr.forEach((item) => {\r\n     const { id, value } = item\r\n         , country = _fnIdToCountry(id);\r\n     categories.push(country);     \r\n     data.push({ y: value, c: country })\r\n     if (value>=max) { max = value; }\r\n     if (value<=min) { min = value; }\r\n   })\r\n   return { categories, data, min, max };\r\n}\r\n\r\n/***********************/\r\n\r\nconst _combineToHm = (ids, sGeo) => {\r\n  const hm = {};\r\n  ids.forEach((id, index) => {\r\n    if (sGeo[index] != null && sGeo[index].value != null){\r\n      hm[_fnIdToCountry(id)] = sGeo[index].value;\r\n    }\r\n  })\r\n  return hm;\r\n}\r\nconst _trHmToData = (hm, categories) => {\r\n  const data = []\r\n  categories.forEach((id) => {\r\n    if (hm[id] != null){\r\n      data.push(hm[id]);\r\n      //data.push({ y: hm[id], c: id });\r\n    }\r\n    else {\r\n      //data.push({ y: 0, c: id });\r\n      data.push(0);\r\n    }\r\n  })\r\n  return data;\r\n}\r\n\r\nconst JsonStatFn = {\r\n  createGeoSlice : (json, configSlice) => {\r\n    const  ds = JSONstat(json).Dataset(0);\r\n    let _sGeo = ds.Data(configSlice)\r\n       , time ;\r\n\r\n    if (!_sGeo || _sGeo.length === 0){\r\n      const maxIndex = getFromNullable(ds.Dimension(\"time\").id, []).length;\r\n      if (maxIndex>0) {\r\n        time = ds.Dimension(\"time\").id[maxIndex-1];\r\n        _sGeo = ds.Data({...configSlice, ...{ time } })\r\n      }\r\n    } else {\r\n      time = configSlice.time\r\n    }\r\n\r\n    return {\r\n      dGeo : getFromNullable(ds.Dimension(\"geo\"), { id : []}),\r\n      //sGeo : getFromNullable(ds.Data(configSlice), [])\r\n      sGeo : getFromNullable(_sGeo, []),\r\n      time\r\n    };\r\n  },\r\n\r\n  crGeoSeria: (json, configSlice) => {\r\n    const ds = JSONstat(json).Dataset(0)\r\n        , data = getFromNullable(ds.Data(configSlice), [])\r\n                     .map( obj => obj.value )\r\n                     .filter(value => value !== null);\r\n    return {\r\n      date: getFromNullable(ds.Dimension(\"time\")),\r\n      data: data\r\n    };\r\n  },\r\n\r\n  trJsonToCategory : (json, configSlice) => {\r\n    const { dGeo, sGeo } = JsonStatFn.createGeoSlice(json, configSlice);\r\n\r\n    return _fnFetchHmIdCountry().then(() => {\r\n       return Box( _combineToArr(dGeo.id, sGeo) )\r\n               .map(arr => arr.sort(AdapterFn.compareByValueId))\r\n               .fold(_splitForConfig);\r\n       });\r\n  },\r\n  trJsonToSeria : (json, configSlice, categories) => {\r\n    const { dGeo, sGeo } = JsonStatFn.createGeoSlice(json, configSlice);\r\n    return Box(_combineToHm(dGeo.id, sGeo))\r\n             .fold((hm) => _trHmToData(hm, categories));\r\n  }\r\n}\r\n\r\nexport default JsonStatFn\r\n"]}