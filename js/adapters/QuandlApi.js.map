{"version":3,"sources":["../../src/adapters/QuandlApi.js"],"names":["C","ROOT_URL","REQUEST_ERROR","DATASET_EMPTY","QuandlApi","getRequestUrl","option","value","fromDate","toDate","apiKey","transform","_queryDate","_apiKey","checkResponse","json","quandl_error","dataset","message","errCaption","data","length","newest_available_date","oldest_available_date"],"mappings":";;;;;;AACA,IAAMA,IAAI;AACRC,YAAU,yCADF;;AAGRC,iBAAe,eAHP;AAIRC,iBAAe;AAJP,CAAV;;AAOA,IAAMC,YAAY;AAEhBC,eAFgB,yBAEFC,MAFE,EAEM;AAAA,QACZC,KADY,GACmCD,MADnC,CACZC,KADY;AAAA,QACLC,QADK,GACmCF,MADnC,CACLE,QADK;AAAA,QACKC,MADL,GACmCH,MADnC,CACKG,MADL;AAAA,QACaC,MADb,GACmCJ,MADnC,CACaI,MADb;AAAA,QACqBC,SADrB,GACmCL,MADnC,CACqBK,SADrB;;;AAGpB,QAAIC,aAAa,EAAjB;AACA,QAAKJ,YAAYC,MAAjB,EAAyB;AACvBG,mBAAa,gBAAb;AACA,UAAIJ,QAAJ,EAAc;AACZI,qBAAaA,+BAA4BJ,QAA5B,CAAb;AACD;AACD,UAAIC,MAAJ,EAAW;AACTG,qBAAaA,6BAA0BH,MAA1B,CAAb;AACD;AACF;;AAED,QAAIE,SAAJ,EAAe;AACbC,mBAAaA,8BAA2BD,SAA3B,CAAb;AACD;;AAED,QAAIE,UAAU,EAAd;AACA,QAAIH,MAAJ,EAAW;AACTG,gBAAWD,UAAD,iBACOF,MADP,gBAEMA,MAFhB;AAGD;;AAED,gBAAUV,EAAEC,QAAZ,GAAuBM,KAAvB,cAAqCK,UAArC,GAAkDC,OAAlD;AACD,GA5Be;AA8BhBC,eA9BgB,yBA8BFC,IA9BE,EA8BI;AAAA,QACVC,YADU,GACmBD,IADnB,CACVC,YADU;AAAA,wBACmBD,IADnB,CACIE,OADJ;AAAA,QACIA,OADJ,iCACY,EADZ;;AAElB,QAAKD,YAAL,EAAmB;AAChB,UAAKA,aAAaE,OAAlB,EAA4B;AACzB,cAAM,EAAEC,YAAanB,EAAEE,aAAjB,EAAgCgB,SAAUH,KAAKC,YAAL,CAAkBE,OAA5D,EAAN;AACF,OAFD,MAEO;AACJ,cAAM,EAAEC,YAAanB,EAAEE,aAAjB,EAAgCgB,SAAU,EAA1C,EAAN;AACF;AACH,KAND,MAMO,IAAK,CAACD,QAAQG,IAAT,IAAiBH,QAAQG,IAAR,CAAaC,MAAb,KAAwB,CAA9C,EAAiD;AAAA,kCACWJ,OADX,CAC5CK,qBAD4C;AAAA,UAC5CA,qBAD4C,yCACtB,EADsB;AAAA,kCACWL,OADX,CAClBM,qBADkB;AAAA,UAClBA,qBADkB,yCACI,EADJ;;AAEpD,YAAM;AACHJ,oBAAanB,EAAEG,aADZ;AAEHe,+FAC0BI,qBAD1B,6CAE0BC;AAJvB,OAAN;AAMH;AACD,WAAO,IAAP;AACD;AAhDe,CAAlB;;kBAmDenB,S","file":"QuandlApi.js","sourcesContent":["\r\nconst C = {\r\n  ROOT_URL: \"https://www.quandl.com/api/v3/datasets/\",\r\n\r\n  REQUEST_ERROR: 'Request Error',\r\n  DATASET_EMPTY: 'Dataset Empty'\r\n}\r\n\r\nconst QuandlApi = {\r\n\r\n  getRequestUrl(option) {\r\n    const { value, fromDate, toDate, apiKey, transform } = option;\r\n\r\n    let _queryDate = '';\r\n    if ( fromDate || toDate ){\r\n      _queryDate = 'sort_order=asc'\r\n      if (fromDate) {\r\n        _queryDate = _queryDate + `&trim_start=${fromDate}`\r\n      }\r\n      if (toDate){\r\n        _queryDate = _queryDate + `&trim_end=${toDate}`\r\n      }\r\n    }\r\n\r\n    if (transform) {\r\n      _queryDate = _queryDate + `&transform=${transform}`\r\n    }\r\n\r\n    let _apiKey = '';\r\n    if (apiKey){\r\n      _apiKey = (_queryDate)\r\n         ? `&api_key=${apiKey}`\r\n         : `api_key=${apiKey}`;\r\n    }\r\n\r\n    return `${C.ROOT_URL}${value}.json?${_queryDate}${_apiKey}`;\r\n  },\r\n\r\n  checkResponse(json) {\r\n    const { quandl_error, dataset={} } = json;\r\n    if ( quandl_error ){\r\n       if ( quandl_error.message ) {\r\n          throw { errCaption : C.REQUEST_ERROR, message : json.quandl_error.message };\r\n       } else {\r\n          throw { errCaption : C.REQUEST_ERROR, message : '' };\r\n       }\r\n    } else if ( !dataset.data || dataset.data.length === 0 ){\r\n        const { newest_available_date='', oldest_available_date='' } = dataset;\r\n        throw {\r\n           errCaption : C.DATASET_EMPTY,\r\n           message : `Result dataset for request is empty:\r\n                      Newest Date: ${newest_available_date}\r\n                      Oldest Date: ${oldest_available_date}`\r\n        };\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\nexport default QuandlApi\r\n"]}